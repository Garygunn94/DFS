Preprocessing library DirectoryServer-0.1.0.0...
[1 of 2] Compiling DirectoryServer  ( src/DirectoryServer.hs, .stack-work/dist/x86_64-linux/Cabal-1.24.0.0/build/DirectoryServer.o )

src/DirectoryServer.hs:129:5: error:
    Variable not in scope:
      closeFile :: File -> ExceptT ServantErr IO Response

src/DirectoryServer.hs:139:35: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘m1 ()’
    • In the expression:
        liftIO
        $ do { warnLog
               $ "Storing file under key " ++ key ++ "." withMongoDbConnection
                 $ upsert (select ["id" =: key] "FILESERVER_RECORD")
                   $ toBSON fs return True }
      In an equation for ‘storefs’:
          storefs fs@(FileServer key _ _)
            = liftIO
              $ do { warnLog
                     $ "Storing file under key " ++ key ++ "." withMongoDbConnection
                       $ upsert (select ["id" =: key] "FILESERVER_RECORD")
                         $ toBSON fs return True }

src/DirectoryServer.hs:140:15: error:
    • Couldn't match expected type ‘Action m2 () -> String’
                  with actual type ‘[Char]’
    • The first argument of ($) takes one argument,
      but its type ‘[Char]’ has none
      In the second argument of ‘($)’, namely
        ‘"Storing file under key " ++ key ++ "." withMongoDbConnection
         $ upsert (select ["id" =: key] "FILESERVER_RECORD")
           $ toBSON fs return True’
      In a stmt of a 'do' block:
        warnLog
        $ "Storing file under key " ++ key ++ "." withMongoDbConnection
          $ upsert (select ["id" =: key] "FILESERVER_RECORD")
            $ toBSON fs return True

src/DirectoryServer.hs:141:85: error:
    • Couldn't match expected type ‘(a1 -> m3 a1) -> Bool -> Document’
                  with actual type ‘[Field]’
    • The function ‘toBSON’ is applied to three arguments,
      but its type ‘FileServer -> [Field]’ has only one
      In the second argument of ‘($)’, namely ‘toBSON fs return True’
      In the second argument of ‘($)’, namely
        ‘upsert (select ["id" =: key] "FILESERVER_RECORD")
         $ toBSON fs return True’

src/DirectoryServer.hs:145:36: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘m0 Bool’
    • In the expression:
        liftIO
        $ do { warnLog $ "Storing file under key " ++ key ++ ".";
               withMongoDbConnection
               $ upsert (select ["id" =: key] "FILEMAPPING_RECORD") $ toBSON fm;
               return True }
      In an equation for ‘storefm’:
          storefm fm@(FileMapping key _ _)
            = liftIO
              $ do { warnLog $ "Storing file under key " ++ key ++ ".";
                     withMongoDbConnection
                     $ upsert (select ["id" =: key] "FILEMAPPING_RECORD") $ toBSON fm;
                     return True }

src/DirectoryServer.hs:152:5: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘IO Bool’
    • In a stmt of a 'do' block:
        manager <- newManager defaultManagerSettings
      In the expression:
        do { manager <- newManager defaultManagerSettings;
             res <- runClientM
                      getFilesQuery
                      (ClientEnv
                         manager (BaseUrl Http (fsaddress fs) (read (fsport fs)) ""));
             case res of {
               Left err -> putStrLn $ "Error: " ++ show err
               Right response
                 -> map (storefm (fsaddress fs) (fsport fs)) response };
             return True }
      In an equation for ‘getStoreFm’:
          getStoreFm fs
            = do { manager <- newManager defaultManagerSettings;
                   res <- runClientM
                            getFilesQuery
                            (ClientEnv
                               manager (BaseUrl Http (fsaddress fs) (read (fsport fs)) ""));
                   case res of {
                     Left err -> putStrLn $ "Error: " ++ show err
                     Right response
                       -> map (storefm (fsaddress fs) (fsport fs)) response };
                   .... }

src/DirectoryServer.hs:156:27: error:
    • Couldn't match type ‘[]’ with ‘IO’
      Expected type: IO ()
        Actual type: [()]
    • In the expression:
        map (storefm (fsaddress fs) (fsport fs)) response
      In a case alternative:
          Right response -> map (storefm (fsaddress fs) (fsport fs)) response
      In a stmt of a 'do' block:
        case res of {
          Left err -> putStrLn $ "Error: " ++ show err
          Right response
            -> map (storefm (fsaddress fs) (fsport fs)) response }

src/DirectoryServer.hs:156:32: error:
    • Couldn't match expected type ‘String -> FilePath -> ()’
                  with actual type ‘Bool’
    • The function ‘storefm’ is applied to two arguments,
      but its type ‘FileMapping -> Bool’ has only one
      In the first argument of ‘map’, namely
        ‘(storefm (fsaddress fs) (fsport fs))’
      In the expression:
        map (storefm (fsaddress fs) (fsport fs)) response

src/DirectoryServer.hs:156:41: error:
    • Couldn't match type ‘[Char]’ with ‘FileMapping’
      Expected type: FileMapping
        Actual type: String
    • In the first argument of ‘storefm’, namely ‘(fsaddress fs)’
      In the first argument of ‘map’, namely
        ‘(storefm (fsaddress fs) (fsport fs))’
      In the expression:
        map (storefm (fsaddress fs) (fsport fs)) response

src/DirectoryServer.hs:161:17: error:
    • Couldn't match expected type ‘ExceptT ServantErr IO a2’
                  with actual type ‘Bool’
    • In a stmt of a 'do' block: bool <- storefs fs
      In the expression:
        do { bool <- storefs fs;
             bool2 <- getStoreFm fs;
             return (Response "Success") }
      In an equation for ‘fsJoin’:
          fsJoin fs
            = do { bool <- storefs fs;
                   bool2 <- getStoreFm fs;
                   return (Response "Success") }

src/DirectoryServer.hs:162:18: error:
    • Couldn't match expected type ‘ExceptT ServantErr IO a3’
                  with actual type ‘Bool’
    • In a stmt of a 'do' block: bool2 <- getStoreFm fs
      In the expression:
        do { bool <- storefs fs;
             bool2 <- getStoreFm fs;
             return (Response "Success") }
      In an equation for ‘fsJoin’:
          fsJoin fs
            = do { bool <- storefs fs;
                   bool2 <- getStoreFm fs;
                   return (Response "Success") }

src/DirectoryServer.hs:170:21: error:
    • Couldn't match type ‘Maybe’
                     with ‘Control.Monad.Trans.Reader.ReaderT MongoContext IO’
      Expected type: Control.Monad.Trans.Reader.ReaderT
                       MongoContext IO FileMapping
        Actual type: Maybe FileMapping
    • In a stmt of a 'do' block:
        file <- head $ map (\ b -> fromBSON b :: Maybe FileMapping) docs
      In the second argument of ‘($)’, namely
        ‘do { docs <- find
                        (select ["fmfileName" =: key] "FILEMAPPING_RECORD")
                      >>= drainCursor;
              file <- head $ map (\ b -> fromBSON b :: Maybe FileMapping) docs;
              return file }’
      In a stmt of a 'do' block:
        withMongoDbConnection
        $ do { docs <- find
                         (select ["fmfileName" =: key] "FILEMAPPING_RECORD")
                       >>= drainCursor;
               file <- head $ map (\ b -> fromBSON b :: Maybe FileMapping) docs;
               return file }

src/DirectoryServer.hs:175:9: error:
    • Couldn't match expected type ‘File’ with actual type ‘IO ()’
    • In a stmt of a 'do' block:
        manager <- newManager defaultManagerSettings
      In the expression:
        do { manager <- newManager defaultManagerSettings;
             res <- runClientM
                      (downloadQuery key)
                      (ClientEnv
                         manager (BaseUrl Http (fmaddress fm) (read (fmport fm)) ""));
             case res of {
               Left err -> putStrLn $ "Error: " ++ show err
               Right response -> return response } }
      In an equation for ‘openFileQuery’:
          openFileQuery key fm
            = do { manager <- newManager defaultManagerSettings;
                   res <- runClientM
                            (downloadQuery key)
                            (ClientEnv
                               manager (BaseUrl Http (fmaddress fm) (read (fmport fm)) ""));
                   case res of {
                     Left err -> putStrLn $ "Error: " ++ show err
                     Right response -> return response } }

src/DirectoryServer.hs:179:30: error:
    • Couldn't match type ‘File’ with ‘()’
      Expected type: IO ()
        Actual type: IO File
    • In the expression: return response
      In a case alternative: Right response -> return response
      In a stmt of a 'do' block:
        case res of {
          Left err -> putStrLn $ "Error: " ++ show err
          Right response -> return response }

src/DirectoryServer.hs:183:23: error:
    • Couldn't match type ‘Maybe’ with ‘ExceptT ServantErr IO’
      Expected type: ExceptT ServantErr IO FileMapping
        Actual type: Maybe FileMapping
    • In a stmt of a 'do' block: fm <- searchFileMappings key
      In the expression:
        do { fm <- searchFileMappings key;
             case fm of {
               Nothing -> putStrLn $ "Error: " ++ "File not found"
               Just filemapping -> do { ... } } }
      In an equation for ‘openFile’:
          openFile key
            = do { fm <- searchFileMappings key;
                   case fm of {
                     Nothing -> putStrLn $ "Error: " ++ "File not found"
                     Just filemapping -> ... } }

src/DirectoryServer.hs:185:25: error:
    • Couldn't match expected type ‘FileMapping’
                  with actual type ‘Maybe t0’
    • In the pattern: Nothing
      In a case alternative:
          Nothing -> putStrLn $ "Error: " ++ "File not found"
      In a stmt of a 'do' block:
        case fm of {
          Nothing -> putStrLn $ "Error: " ++ "File not found"
          Just filemapping
            -> do { file <- openFileQuery key filemapping;
                    return file } }

src/DirectoryServer.hs:185:36: error:
    • Couldn't match type ‘IO’ with ‘ExceptT ServantErr IO’
      Expected type: ExceptT ServantErr IO File
        Actual type: IO ()
    • In the expression: putStrLn $ "Error: " ++ "File not found"
      In a case alternative:
          Nothing -> putStrLn $ "Error: " ++ "File not found"
      In a stmt of a 'do' block:
        case fm of {
          Nothing -> putStrLn $ "Error: " ++ "File not found"
          Just filemapping
            -> do { file <- openFileQuery key filemapping;
                    return file } }

src/DirectoryServer.hs:186:25: error:
    • Couldn't match expected type ‘FileMapping’
                  with actual type ‘Maybe FileMapping’
    • In the pattern: Just filemapping
      In a case alternative:
          Just filemapping
            -> do { file <- openFileQuery key filemapping;
                    return file }
      In a stmt of a 'do' block:
        case fm of {
          Nothing -> putStrLn $ "Error: " ++ "File not found"
          Just filemapping
            -> do { file <- openFileQuery key filemapping;
                    return file } }

src/DirectoryServer.hs:187:41: error:
    • Couldn't match expected type ‘ExceptT ServantErr IO File’
                  with actual type ‘File’
    • In a stmt of a 'do' block: file <- openFileQuery key filemapping
      In the expression:
        do { file <- openFileQuery key filemapping;
             return file }
      In a case alternative:
          Just filemapping
            -> do { file <- openFileQuery key filemapping;
                    return file }
